/*var dotWidth:Number = 4;var spaceBetweenDots:Number = 0;var totalLineWidth:Number = 250;var dotsPerLine:Number = totalLineWidth / (dotWidth + spaceBetweenDots);var ragVariance: Number = 2;for (var i:Number = 0; i < dotsPerLine; i++){       var raggedLine:MovieClip = _root.createEmptyMovieClip("topLine_" + i, this.getNextHighestDepth());    raggedLine.lineStyle(0, 0x000000, 100);    raggedLine.lineTo(dotWidth-random(ragVariance), random(ragVariance));    raggedLine._x = i * (dotWidth + random(spaceBetweenDots));    raggedLine._y = 100+random(ragVariance);}*///AS2/*}*//** * Copyright tkinjo ( http://wonderfl.net/user/tkinjo ) * MIT License ( http://www.opensource.org/licenses/mit-license.php ) * Downloaded from: http://wonderfl.net/c/nIRM */// forked from tkinjo's ひもっぽい何か// forked from tkinjo's 点の追従package  {	/**	 * 参考	 * 	 * bouze's hybrid-brush-05	 * http://wonderfl.kayac.com/code/ff5d0155b7268a766c3bc22da04be974a0778d0e	 */		import flash.display.Bitmap;	import flash.display.BitmapData;	import flash.display.Sprite;	import flash.events.Event;	import flash.geom.Matrix;	import flash.geom.Point;		[SWF(width="465", height="465", frameRate="60", backgroundColor="0xeeeeff")]	/**	 * ...	 * @author tkinjo	 */	public class tmp extends Sprite {										// 点の数		private const dotNum:int = 70;				// 点の半径		private const dotRadius:uint = 15;				// 点と点との距離		private const distance:uint = 5;						// 点の配列		private var dots:Array = new Array();				/**		 * コンストラクタ		 */		public function tmp() {															createDots();						// フレームごとにループ			addEventListener(Event.ENTER_FRAME, function( event:Event ):void {										calc();					draw();				} );		}				/**		 * 点の作成		 */		private function createDots():void {						for ( var i:uint = 0; i < dotNum; i++) {								var dot:Point = new Point( mouseX, mouseY );				dots.push( dot );			}		}				/** --------------------------------------------------		 * 計算		 */		private function calc():void {						for ( var i:uint = 0; i < dotNum; i++ ) {								// 座標の算出				if ( i == 0 ) {										dots[ i ].x = mouseX;					dots[ i ].y = mouseY;									} else {										var angle:Number = Math.atan2( dots[ i ].y - dots[ i - 1 ].y, dots[ i ].x - dots[ i - 1 ].x );					dots[ i ].x = dots[ i - 1 ].x + distance * Math.cos( angle );					dots[ i ].y = dots[ i - 1 ].y + distance * Math.sin( angle );				}			}		}				/** --------------------------------------------------		 * 描画		 */		 		 private function sketch(_x1:Number, _y1:Number, _x2:Number, _y2:Number):void{			 for (var j:Number = 0; j < 10; j++)		{			graphics.lineStyle(Math.random()*2, 0x000000, 100);			graphics.moveTo (alea(_x2)-_x1,alea(_y2)-_y1 );			graphics.lineTo (alea(_x2)-_x1,alea(_y2)-_y1 );				}		 }		 function alea(limit:Number):Number{	var randomNumber:Number = Math.floor(Math.random()*(limit+1));	return randomNumber;}		 		private function draw():void {					/*var dotWidth:Number = 1;		var spaceBetweenDots:Number = 0;		var totalLineWidth:Number = 250;		var dotsPerLine:Number = totalLineWidth / (dotWidth + spaceBetweenDots);		var ragVariance: Number = 10;		graphics.clear();				for (var j:Number = 0; j < dotsPerLine; j++)		{   			//var raggedLine:Sprite = new Sprite();			//this.removeChild(raggedLine+'j')			//raggedLine.name = 'raggedLine'+j;			//this.addChild(raggedLine);			var _x:Number = j * (dotWidth + Math.random()*(spaceBetweenDots));			var _y:Number = 100+Math.random()*(ragVariance);						graphics.lineStyle(Math.random()*1, 0x000000, 100);			graphics.moveTo (_x, _y);			graphics.lineTo(_x+dotWidth-Math.random()*(ragVariance), _y+Math.random()*(ragVariance));						/* graphics.moveTo (10, 10);			 graphics.lineTo( 20, 10);			  graphics.moveTo (30, 10);			  graphics.lineTo( 40, 10);			  		}		*/									graphics.clear();			//graphics.beginFill( 0 );			graphics.lineStyle( 1, 0xcccccc );						for ( var i:uint = 0; i < dotNum; i++ ) {								if( i == 0 ){					//graphics.drawCircle( dots[ i ].x, dots[ i ].y, dotRadius );					//graphics.moveTo( dots[ 0 ].x, dots[ 0 ].y );					//sketch( dots[ 0 ].x, dots[ 0 ].y,dots[ 0 ].x, dots[ 0 ].y );					sketch (20, 30, 70, 84);									}else {										var angle:Number = Math.atan2( dots[ i ].y - dots[ i - 1 ].y, dots[ i ].x - dots[ i - 1 ].x );										if ( i % 2 == 0 )						angle += ( 90 / 360 ) * ( 2 * Math.PI );											else						angle -= ( 90 / 360 ) * ( 2 * Math.PI );										//graphics.lineStyle( Math.random()*3, 0xcccccc );										//graphics.lineTo( dots[ i ].x + Math.random()*dotRadius * Math.cos( angle ), dots[ i ].y + Math.random()*dotRadius * Math.sin( angle ));					//graphics.lineStyle( 1, 0xcccccc );					//graphics.drawCircle( dots[ i ].x + dotRadius * Math.cos( angle ), dots[ i ].y + dotRadius * Math.sin( angle ), dotRadius+ Math.random()*2 );				}			}						//graphics.endFill();						// -----						//graphics.lineStyle( 1, 0xcccccc );			//graphics.moveTo( dots[ 0 ].x, dots[ 0 ].y );						for ( i = 1; i < dotNum; i++ ) {								angle = Math.atan2( dots[ i ].y - dots[ i - 1 ].y, dots[ i ].x - dots[ i - 1 ].x ) + ( 90 / 360 ) * ( 2 * Math.PI );				//graphics.lineTo( dots[ i ].x + ( dotRadius * 4 ) * Math.cos( angle ), dots[ i ].y + ( dotRadius * 4 ) * Math.sin( angle ) );			}						for ( i = dotNum - 1; i > 0; i-- ) {								angle = Math.atan2( dots[ i ].y - dots[ i - 1 ].y, dots[ i ].x - dots[ i - 1 ].x ) - ( 90 / 360 ) * ( 2 * Math.PI );				//graphics.lineTo( dots[ i ].x + ( dotRadius * 4 ) * Math.cos( angle ), dots[ i ].y + ( dotRadius * 4 ) * Math.sin( angle ) );			}			//graphics.lineTo( dots[ 0 ].x, dots[ 0 ].y );		}	}}